# Object

Objects are GC-aware complex structs, which means they are managed by the garbage collector and therefore can only be
allocated on the heap.

Additionally, they have a pointer to a Type which provides metadata information about the type, including callback
hooks,
for example, the GC.

Based on those two rules, the object is not different from a normal struct.

## Layout

Objects are like struct sequences aware. Important to note is that the first `sizeof(void*)` bytes are reserved to
a global type struct. All objects of the same type should have the same type struct pointer.

## Type

A Type is a special struct that must be implemented for each object once. It contains information about the type, such
as special hooks that are called in certain situations e.g., GC marking phase.

A general type declaration could look like this

```c
ObjectType TestObject_Type = {
    .trace = test_object_trace
};
```

Normally these things are generated by the compiler. But it makes sense for the future to override these hooks with
custom user-implemented functions.

Which could look like the following:

```
[GCTraceHandler(MyType)]
func gc_mark_handler(obj: MyType, mark: Action<Object>): void {
    // Mark all children objects of MyType
}
```

## Instantiation

A Type can be instantiated with `new`. This approach was chosen because it directly clarifies that the memory needs to
be allocated on the heap. In the generated C code the `OBJECT_CTOR` macro is used to instantiate a new object.

In the future it'll make sense to additionally support a user-defined function that acts as constructor, so that
directly the raw-memory is overwritten with a defined behavior.

This could look like the following:

```
[TypeCtor(MyType)]
func my_type_ctor(obj: MyType): void {
    // setting fields to a defined behavor
    obj.myValue = 0;
}
```

In the same opportunity a destructor could also be implemented that is called before the object is consumed by the GC.