extern func fs_get_stderr(): Object;

enum DiagnosticCode {
    // Lexer
    UNEXPECTED_CHAR,
    UNCLOSED_STRING,
    UNCLOSED_CHAR,

    // Parser
    EXPECTED_TOKEN,
    UNEXPECTED_TOKEN,
    EMPTY_GENERIC,

    // Binder
    EMPTY_FUNC_GENERIC,
    SPAN_SIGNATURE,
    UNKNOWN_DYNAMIC,
    UNKNOWN_TYPE,
    INVALID_CTOR,
    NOT_ASSIGNABLE,
    UNKNOWN_UNARY_OPERATOR,
    UNKNOWN_BINARY_OPERATOR,
    NOT_ACCESSABLE,
    PROPERTY_NOT_FOUND,
}

type DiagnosticBag {
    list: ObjectList;
}

type Diagnostic {
    code: DiagnosticCode;
    span: LocationSpan;
    args: ObjectList;
}

func diagnosticBag_init(): DiagnosticBag {
    let diagnostics: DiagnosticBag = new DiagnosticBag();

    diagnostics.list = list_init();

    return diagnostics;
}

func diagnostic_init(code: DiagnosticCode, span: LocationSpan, args: ObjectList): Diagnostic {
    let diagnostic: Diagnostic = new Diagnostic();
	
    diagnostic.code = code;
	diagnostic.span = span;
    diagnostic.args = args;

    return diagnostic;
}

func report_unexpected_char(bag: DiagnosticBag, span: LocationSpan, value: String): void {
    let args: ObjectList = list_init();
    list_push(args, value);

    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.UNEXPECTED_CHAR, span, args);
    list_push(bag.list, diagnostic);
}

func report_unclosed_string(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.UNCLOSED_STRING, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_unclosed_char(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.UNCLOSED_CHAR, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_expected_token(bag: DiagnosticBag, span: LocationSpan, got: TokenKind, expected: TokenKind): void {
    let args: ObjectList = list_init();
    list_push(args, box_i32(got));
    list_push(args, box_i32(expected));
    
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.EXPECTED_TOKEN, span, args);
}

func report_expected_token2(bag: DiagnosticBag, span: LocationSpan, got: TokenKind, expected1: TokenKind, expected2: TokenKind): void {
    let args: ObjectList = list_init();
    list_push(args, box_i32(got));
    list_push(args, box_i32(expected1));
    list_push(args, box_i32(expected2));
    
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.EXPECTED_TOKEN, span, args);
}

func report_empty_generic(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.EMPTY_GENERIC, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_empty_func_generic(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.EMPTY_FUNC_GENERIC, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_span_signature(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.SPAN_SIGNATURE, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_unknown_dynamic_type(bag: DiagnosticBag, span: LocationSpan, identifier: String): void {
    let args: ObjectList = list_init();
    list_push(args, identifier);

    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.UNKNOWN_DYNAMIC, span, args);
    list_push(bag.list, diagnostic);    
}

func report_unknown_type(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.SPAN_SIGNATURE, span, list_init());
    list_push(bag.list, diagnostic);    
}

func report_invalid_ctor_signature(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.INVALID_CTOR, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_not_assignable(bag: DiagnosticBag, span: LocationSpan): void {
    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.NOT_ASSIGNABLE, span, list_init());
    list_push(bag.list, diagnostic);
}

func report_unknown_unary_operator(bag: DiagnosticBag, span: LocationSpan, operator: TokenKind, rightType: DataType): void {
    let args: ObjectList = list_init();
    list_push(args, box_i32(operator));
    list_push(args, rightType);

    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.UNKNOWN_UNARY_OPERATOR, span, args);
    list_push(bag.list, diagnostic);
}

func report_unknown_binary_operator(bag: DiagnosticBag, span: LocationSpan, operator: TokenKind, leftType: DataType, rightType: DataType): void {
    let args: ObjectList = list_init();
    list_push(args, box_i32(operator));
    list_push(args, leftType);
    list_push(args, rightType);

    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.UNKNOWN_BINARY_OPERATOR, span, args);
    list_push(bag.list, diagnostic);
}

func report_not_accessable(bag: DiagnosticBag, span: LocationSpan, base: DataType): void {
    let args: ObjectList = list_init();
    list_push(args, base);

    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.NOT_ACCESSABLE, span, args);
    list_push(bag.list, diagnostic);
}

func report_unkown_property(bag: DiagnosticBag, span: LocationSpan, base: DataType, property: String): void {
    let args: ObjectList = list_init();
    list_push(args, base);
    list_push(args, property);

    let diagnostic: Diagnostic = diagnostic_init(DiagnosticCode.PROPERTY_NOT_FOUND, span, args);
    list_push(bag.list, diagnostic);
}

func diagnostic_print_code_message(fd: Object, code: DiagnosticCode, args: ObjectList): void {
    if (code == DiagnosticCode.UNEXPECTED_CHAR) {
        let c: String = <String>list_get_value(args, 0);
        fs_write_string(fd, "Unexpected character '");
        fs_write_string(fd, c);
        fs_write_string(fd, "'");
    } else if (code == DiagnosticCode.UNCLOSED_STRING) {
        fs_write_string(fd, "Unterminated string literal");    
    } else if (code == DiagnosticCode.UNCLOSED_CHAR) {
        fs_write_string(fd, "Unterminated char literal");    
    } else if (code == DiagnosticCode.EXPECTED_TOKEN) {
        let got: i32 = (<I32>list_get_value(args, 0)).value;
        let expected: i32 = (<I32>list_get_value(args, 1)).value;
        
        fs_write_string(fd, "Expected token '");
        // TODO replace with actually token content
        fs_write_int(fd, expected);
        fs_write_string(fd, "'");

        if (args.length == 3) {
            let expected: i32 = (<I32>list_get_value(args, 2)).value;
            fs_write_string(fd, ", or '");
            // TODO replace with actually token content
            fs_write_int(fd, expected);
            fs_write_string(fd, "'");
        }

        fs_write_string(fd, ", but got '");
        // TODO replace with actually token content
        fs_write_int(fd, got);
        fs_write_string(fd, "'");
    } else if (code == DiagnosticCode.UNEXPECTED_TOKEN) {
        let got: i32 = (<I32>list_get_value(args, 0)).value;
        
        fs_write_string(fd, "Unexpected token '");
        // TODO replace with actually token content
        fs_write_int(fd, got);
        fs_write_string(fd, "'");
    } else if (code == DiagnosticCode.EMPTY_GENERIC) {
        fs_write_string(fd, "Generic part of a Type cannot be empty");
    } else if (code == DiagnosticCode.EMPTY_FUNC_GENERIC) {
        fs_write_string(fd, "'Func' Type must have at least one generic");
    } else if (code == DiagnosticCode.SPAN_SIGNATURE) {
        fs_write_string(fd, "'Span' Must have exactly one generic");
    } else if (code == DiagnosticCode.UNKNOWN_DYNAMIC) {
        let c: String = <String>list_get_value(args, 0);
        
        fs_write_string(fd, "Unkown dynamic type '");
        fs_write_string(fd, c);
        fs_write_string(fd, "'");
    } else if (code == DiagnosticCode.UNKNOWN_TYPE) {
        fs_write_string(fd, "Unknown Type");
    } else if (code == DiagnosticCode.INVALID_CTOR) {
        fs_write_string(fd, "The Type cannot be instantiated");
    } else if (code == DiagnosticCode.NOT_ASSIGNABLE) {
        fs_write_string(fd, "Expression is not assignable");
    } else if (code == DiagnosticCode.UNKNOWN_UNARY_OPERATOR) {
        let tokenKind: i32 = (<I32>list_get_value(args, 0)).value;
        let rightType: DataType = <DataType>list_get_value(args, 1);

        fs_write_string(fd, "Unknown unary operator '");
        fs_write_int(fd, tokenKind);
        // TODO replace with actually token content
        fs_write_string(fd, "' for '");
        fs_write_string(fd, rightType.name);
        fs_write_string(fd, "'");
    } else if (code == DiagnosticCode.UNKNOWN_BINARY_OPERATOR) {
        let tokenKind: i32 = (<I32>list_get_value(args, 0)).value;
        let leftType: DataType = <DataType>list_get_value(args, 1);
        let rightType: DataType = <DataType>list_get_value(args, 2);

        fs_write_string(fd, "Unknown binary operator '");
        fs_write_int(fd, tokenKind);
        // TODO replace with actually token content
        fs_write_string(fd, "' for '");
        fs_write_string(fd, rightType.name);
        fs_write_string(fd, "' and '");
        fs_write_string(fd, leftType.name);
        fs_write_string(fd, "'");
    } else if (code == DiagnosticCode.NOT_ACCESSABLE) {
        let dataType: DataType = <DataType>list_get_value(args, 0);

        fs_write_string(fd, "Type '");
        fs_write_string(fd, dataType.name);
        fs_write_string(fd, "' is not accessable");
    } else if (code == DiagnosticCode.PROPERTY_NOT_FOUND) {
        let base: DataType = <DataType>list_get_value(args, 0);
        let property: String = <String>list_get_value(args, 1);

        fs_write_string(fd, "Property '");
        fs_write_string(fd, property);
        fs_write_string(fd, "' cannot be found in Type '");
        fs_write_string(fd, property);
        fs_write_string(fd, "'");
    }
}

func diagnostic_print_single(fd: Object, diagnostic: Diagnostic): void {
    let code: DiagnosticCode = diagnostic.code;
    let span: LocationSpan = diagnostic.span;
    let args: ObjectList = diagnostic.args;

    fs_write_string(fd, span.filename);
    fs_write_string(fd, "(");
    fs_write_int(fd, span.startLine);
    fs_write_string(fd, ":");
    fs_write_int(fd, span.startCol);
    fs_write_string(fd, ") [");
    fs_write_string(fd, "LOP");
    fs_write_int(fd, code);
    fs_write_string(fd, "]: ");

    diagnostic_print_code_message(fd, code, args);    

    fs_write_string(fd, "\n");
}

func diagnostic_print(diagnostics: DiagnosticBag): void {
    let fd: Object = fs_get_stderr();
    let iter: ObjectListIterator = list_iterator(diagnostics.list);
    
    while (list_iterator_has_next(iter)) {
        let diagnostic: Diagnostic = <Diagnostic>list_iterator_next(iter);
        diagnostic_print_single(fd, diagnostic);
    }
}