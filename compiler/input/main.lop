extern func gc_mark(): void;
extern func gc_sweep(): void;
extern func gc_mark_sweep(): void;

extern func string_dump(str: String): void;
extern func string_concat(left: String, right: String): String;
extern func string_substring(left: String, start: i32, end: i32): String;
extern func string_char_at(left: String, index: i32): char;
extern func string_equals(left: String, right: String): bool;

extern func fs_read_file(path: String): String;

extern type String {
    buff: Span<char>;
    length: i32;
}

func entry(args: ObjectList): i32 {
    let iter: ObjectListIterator = list_iterator(args);
    // Remove arg0 pointing to executable
    list_iterator_next(iter);
    if (!list_iterator_has_next(iter)) {
        return 1;
    }

    let output: String = <String>list_iterator_next(iter);
	let diagnostics: DiagnosticBag = diagnosticBag_init();
    
    let units: ObjectList = list_init();
    while (list_iterator_has_next(iter)) {
        let file: String = <String>list_iterator_next(iter);

        let content: String = fs_read_file(file);
		let diagnosticCount: i32 = diagnostics.list.length;
        let parser: Parser = parser_init(diagnostics, file, content);
        
		if (diagnosticCount != diagnostics.list.length) {
			continue;
		}
		
		let unit: CompilationUnit = parse_compilation_unit(parser);
		
        list_push(units, unit);
    }

    if (diagnostics.list.length > 0) {
        diagnostic_print(diagnostics);
        return 1;
    }

    if (units.length == 0) {
        return 1;
    }

    let binder: Binder = binder_init(diagnostics, units);
    let program: BoundProgram = binder_bind(binder);

    if (diagnostics.list.length > 0) {
        diagnostic_print(diagnostics);
        return 1;
    }

    let outputFile: Object = fs_open_file(output);

    let emitter: Emitter = emitter_init(outputFile);
    emit_program(emitter, program);

    fs_close_file(outputFile);

    return 0;
}
